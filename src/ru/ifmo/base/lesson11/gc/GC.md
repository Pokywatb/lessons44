#### [Модель памяти java](img/java-memory-model.png)
1. Heap память - хранилище объектов. Создаваемые объекты попадают в эту область памяти. 
Данная область памяти создается при старте JVM и является общей для всех потоков программы. 
Heap память дополнительно делится на зоны, принцип деления зависит от реализации JVM. 
В heap области памяти работает сборщик мусора, он удаляет неиспользуемые объекты и тем самым очищает место для новых.

2. Stack вызовов - область оперативной памяти, которая создается отдельно для каждого потока. 
Stack вызовов работает по принципу LIFO (Last In First Out). 
Когда вызывается метод в stack памяти создается новый блок, который содержит примитивы и ссылки на объекты. 
Когда метод завершает свою работу, блок перестает использоваться (память высвобождается), предоставляется доступ для следующего метода. 
Размер stack памяти гораздо меньше heap памяти.

3. PermGen (до java 8)  MetaSpace (начиная с java 8).
Различия: MetaSpace в отличие от PermGen получило возможность динамически расширятся.
Это область, предназначенная для хранения описания классов Java (экземпляры класса Class<T>), статических данных.
Здесь же с Java 7 хранится пул строк. 

4. Генерируя собственный код, java  сохраняет его в области памяти [Code Cache](https://docs.oracle.com/javase/8/embedded/develop-apps-platforms/codecache.htm)

#### [Загрузка классов ](img/class-loader.gif)
Обычно классы загружаются по мере надобности, за небольшим исключением. 
Некоторые базовые классы  (например, java.lang.*) загружаются при старте приложения.
За загрузку классов в виртуальную машину Java отвечают загрузчики классов. 
Простые приложения могут использовать встроенное средство загрузки, сложные приложения, определяют свои собственные загрузчики классов.

У каждого класса есть ссылка свой загрузчик. 
1. Базовый загрузчик (bootstrap class loader) реализован самой JVM и не может быть создан из кода приложения.
Он загружает основные системные классы.
2. Стандартный загрузчик классов расширений (extension class loader) является дочерним элементом bootstrap loader.
Необходим для загрузки классов из каталогов расширений, Jar-архивы, обычно расположенные в каталоге jre/lib/ext. 
3. Загрузчик системных классов (классов приложений) (system class loader) является дочерним элементом extension loader.
По умолчанию этот загрузчик классов является родителем любого загрузчика классов, созданного разработчиком приложения. 

Как происходит загрузка классов:
[схема 1](img/class-loading1.png)
[схема 2](img/class-loading2.png)
Классы передают друг другу запрос на загрузку класса. Во главе этой иерархии стоит bootstrap class loader.
При загрузке класса Загрузчик проверяет класс в кэше (возможно, он его уже загружал), 
если не находит, то передает запрос на загрузку родителю, если родитель не может загрузить класс, 
то то Загрузчик класса ищет свой собственный путь загрузки класса.
При этом загрузчик классов может видет классы, загруженны им самим или его родителем.


#### [Сборщики мусора (Garbage Collector)](img/gc.jpg) работают в heap памяти.
Мы можем выбрать алгоритм сборки мусора (если позволяет JVM), 
можем настроить сборщик мусора (через доступные опции),
НО мы не можем запускать и останавливать сборщик мусора, когда захотим
(точнее, можем вызвать его System.gc(), но окончательное решение все равно будет принято виртуальной машиной).

Некоторые определения:
Stop-The-World - остановка выполнения программы во время работы GC
Heap память делится на [зоны](img/java-heap.png). 
Принцип деления зависит от конкретного сборщика. Сборщики мусора по-разному ведут себя в этих зонах:
1. Eden - молодое поколение
2. Survivor - выжившие после сборки мусора объекты
3. Tunered - старшее поколение

##### [Последовательный (Serial) и параллельный (Parallel) сборщики мусора](img/serial-and-parallel.png)
1. Serial GC - последовательный сборщик мусора
Даление на поколения: Eden - Survivor1 - Survivor2 | Tunered
Останавливает работу приложения (Stop-The-World) на время сборки мусора.

2. Parallel GC - параллельный сборщик мусора
Деление на поколения: Tunered | Eden - Survivor1 - Survivor2
При необходимости увеличивает размеры областей на 20% и уменьшает на 5%.
Останавливает работу приложения (Stop-The-World) на время сборки мусора.
Сам работает в несколько потоков. Полезен для использования на машинах с несколькими процессорами
Для машин с N < 8 процессорами создает N потоков 
для машин с N >= 8 целую часть от 5N/8 потоков

Принцип работы с областями Eden / Survivor1 / Tunered обоих сборщиков:
Чаще всего сборка мусора происходит в поколении Eden и Survivor. 
Выжившие объекты переносятся в область Survivor, при этом второй Survivor остается пустым. 
При следующей сборке мусора сборка происходит в Eden и Survivor . 
Выжившие объекты переносятся в пустую Survivor область и так далее. 
Объекты, которые живут достаточно долго переносятся в Tunered, там сборка осуществляется реже всего.

##### [Сборщики мусора G1 (Garbage First) и параллельный G1 (Garbage First)](img/G1.png)
G1 GC используется в java 9 
Параллельный G1 GC используется в java 10

Деление на поколения:  Eden - Survivor - Tunered
Минимальное время Stop-The-World на время сборки мусора.

В heap память создается несколько областей Eden, несколько Survivor и несколько Tunered, некоторые области кучи остаются не тронутыми. 
Анализ и выделение объектов, подлежащих уничтожению происходит параллельно с выполнением приложения. 
Перед сборкой мусора приложение останавливается, происходит окончательная оценка того, какие объекты должны быть удалены, 
сборщик мусора уничтожает объекты. Приложение возобновляет работу. Объекты из молодого поколения и из Survivor  
перемещаются в другие Survivor , объекты, живущие достаточно долго перемещаются в Tunered. 
При необходимости выделяются новые области / удаляются старые.















